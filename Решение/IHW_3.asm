.include "macro-syscalls.asm"

.eqv    NAME_SIZE 256	# Размер буфера для имени файла
.eqv    ANSWER_SIZE 256	# Размер буфера для ответа пользователя
.eqv    TEXT_SIZE 512	# Размер буфера для текста

.data
er_name_mes:    .asciz "Incorrect file name\n"
er_read_mes:    .asciz "Incorrect read operation\n"
y:				.asciz "Y"
yes:  			.asciz "Yes, this is a palindrome\n"
no:  			.asciz "No, this is not a palindrome\n"
answer:      	.space	ANSWER_SIZE		# Ответ пользователя
file_name:      .space	NAME_SIZE		# Имя читаемого файла
strbuf:			.space  TEXT_SIZE		# Буфер для читаемого текста

.text
    ###############################################################
    print_str ("Input path to file for reading: ") # Вывод подсказки
    # Ввод имени файла с консоли эмулятора
    str_get(file_name, NAME_SIZE)
    open(file_name, READ_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    beq		a0 s1 er_name	# Ошибка открытия файла
    mv   	s0 a0       	# Сохранение дескриптора файла
    ###############################################################
    # Выделение начального блока памяти для для буфера в куче
    allocate(TEXT_SIZE)		# Результат хранится в a0
    mv 		s3, a0			# Сохранение адреса кучи в регистре
    mv 		s5, a0			# Сохранение изменяемого адреса кучи в регистре
    li		s4, TEXT_SIZE	# Сохранение константы для обработки
    mv		s6, zero		# Установка начальной длины прочитанного текста
    ###############################################################
read_loop:
    # Чтение информации из открытого файла
    ###read(s0, strbuf, TEXT_SIZE)
    read_addr_reg(s0, s5, TEXT_SIZE) # чтение для адреса блока из регистра
    # Проверка на корректное чтение
    beq		a0 s1 er_read	# Ошибка чтения
    mv   	s2 a0       	# Сохранение длины текста
    add 	s6, s6, s2		# Размер текста увеличивается на прочитанную порцию
    # При длине прочитанного текста меньшей, чем размер буфера,
    # необходимо завершить процесс.
    bne		s2 s4 end_loop
    # Иначе расширить буфер и повторить
    allocate(TEXT_SIZE)		# Результат здесь не нужен, но если нужно то...
    add		s5 s5 s2		# Адрес для чтения смещается на размер порции
    b read_loop				# Обработка следующей порции текста из файла
end_loop:
    ###############################################################
    # Закрытие файла
    close(s0)
    #li   a7, 57       # Системный вызов закрытия файла
    #mv   a0, s0       # Дескриптор файла
    #ecall             # Закрытие файла
    ###############################################################
    # Установка нуля в конце прочитанной строки
    ###la	t0 strbuf	 # Адрес начала буфера
    mv	t0 s3		# Адрес буфера в куче
    add t0 t0 s6	# Адрес последнего прочитанного символа
    addi t0 t0 1	# Место для нуля
    sb	zero (t0)	# Запись нуля в конец текста
    ###############################################################
    
    
    ###############################################################
	jal palindrome
    
    ###############################################################
next:    
    # Вывод текста на консоль
    print_str ("Output results to the console?\n")
    print_str ("Y/N?\n")
    str_get (answer, ANSWER_SIZE)
    la a0 answer
    la a1 y
    jal strcmp
    beqz a0 print_file_str
    
    
    ###############################################################
    # Сохранение прочитанного файла в другом файле
    print_str ("Input path to file for writing: ")
    str_get(file_name, NAME_SIZE) # Ввод имени файла с консоли эмулятора
    open(file_name, WRITE_ONLY)
    li		s1 -1			# Проверка на корректное открытие
    beq		a0 s1 er_name	# Ошибка открытия файла
    mv   	s0 a0       	# Сохранение дескриптора файла
	# Запись информации в открытый файл
	li   a7, 64       		# Системный вызов для записи в файл
	mv   a0, s0 			# Дескриптор файла
	beqz s7, else
	la   a1, yes
	li a2 25
	b rag
else:
	la   a1, no
	li a2, 28
rag:    
    ecall   
     
    # Завершение  программы
    exit



palindrome:
    mv a0 s3
    jal strlen
    mv t1 t0
    mv t0 s3
    add t1 t1 t0
    addi t1 t1 -1
	b loop
# Начало цикла проверки палиндрома
loop:
    bge t0, t1, pal   	# Если указатели встретились, переходим к проверке палиндрома
    lb a0, (t0)       			# Загружаем текущий символ из начала строки
    lb a1, (t1)       			# Загружаем текущий символ из конца строки
    beq a0, a1, continue   		# Если символы равны, переходим к следующей итерации
    jal not_pal    		# Если символы не равны, строка не является палиндромом
continue:
    addi t0, t0, 1   			# Увеличиваем указатель начала строки на 1
    addi t1, t1, -1  			# Уменьшаем указатель конца строки на 1
    jal loop             			# Переходим к следующей итерации цикла
pal:  					# Если строка является палиндромом
    li s7, 1  					# В s7 загружаем 1
    jal next
not_pal:     			# Если строка не является палиндромом
    li s7, 0   					# В s7 загружаем 0
	jal next
    
    
er_name:
    # Сообщение об ошибочном имени файла
    la		a0 er_name_mes
    li		a7 4
    ecall
    # И завершение программы
    exit
er_read:
    # Сообщение об ошибочном чтении
    la		a0 er_read_mes
    li		a7 4
    ecall
    # И завершение программы
    exit
print_file_str:
    # Вывод текста на консоль
    li a7 4
    beqz s7, branch
	la   a0, yes
	ecall
    ret
branch:
	la   a0, no
	ecall
    ret
    

strcmp:
loop_1:
    lb      t0 (a0)     # Загрузка символа из 1-й строки для сравнения
    lb      t1 (a1)     # Загрузка символа из 2-й строки для сравнения
    beqz    t0 end_1      # Конец строки 1
    beqz    t1 end_1      # Конец строки 2
    bne     t0 t1 end_1   # Выход по неравенству
    addi    a0 a0 1     # Адрес символа в строке 1 увеличивается на 1
    addi    a1 a1 1     # Адрес символа в строке 2 увеличивается на 1
    b       loop_1
end_1:
    sub     a0 t0 t1    # Получение разности между символами
    ret
    
    
strlen:
    li      t0 0        # Счетчик
loop_2:
    lb      t1 (a0)   # Загрузка символа для сравнения
    beqz    t1 end_2
    addi    t0 t0 1		# Счетчик символов увеличивается на 1
    addi    a0 a0 1		# Берется следующий символ
    b       loop_2
end_2:
    mv      a0 t0
    ret
fatal_2:
    li      a0 -1
    ret

